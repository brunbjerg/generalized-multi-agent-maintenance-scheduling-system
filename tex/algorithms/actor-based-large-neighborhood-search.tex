\newcommand{\MessageQueue}{Q}
\newcommand{\Solution}{X}
\newcommand{\ProblemInstance}{P}
\newcommand{\SharedSolution}{S}

\begin{algorithm}[H]
\caption{Actor-based Large Neighborhood Search} 
\begin{algorithmic}[1]
\State \textbf{Input} $\MessageQueue$    = message queue
\State \textbf{Input} $\ProblemInstance$ = problem instance
\State \textbf{Input} $\Solution$        = initial schedule
\State \textbf{Input} $\SharedSolution$  = SharedSolution
% \State $\Solution^b = \Solution$
\Repeat
	\State $\Solution^t = clone(\Solution)$
	\While{$\MessageQueue.has\_message()$}
        % \State $m = queue.pop()$
        % \State $m.destruct(\Solution^b)$
		\State $\ProblemInstance.update(\SharedSolution, m)$
        \State $\Solution^t.destruct(\SharedSolution, m)$
    \EndWhile
	
    \State $\Solution^t.repair(\SharedSolution)$

    \If{accept($\Solution^t, \Solution$)}                       
        \State $\Solution.update(\Solution^t)$
    \EndIf                                         

    \If{$c(\Solution^t) < c(\Solution)$}                             
        \State $\Solution.update(\Solution^t)$
		\State $\SharedSolution.atomic\_pointer\_swap(\Solution)$
    \EndIf                                           
	\State $\MessageQueue.push(m)$
\Until
\end{algorithmic}
\end{algorithm}

